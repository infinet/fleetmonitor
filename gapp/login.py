#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''The app lives on Google App Engine.
It will negotiate AES key with peers. Those keys are stored in memcache & App
Engine Datastore.
'''


__copyright__ = '2013, Chen Wei <weichen302@gmx.com>'
__version__ = "0.2 2013-04-03"


import os
import sys
import base64
import hashlib
import logging
import wsgiref.handlers
from google.appengine.ext import db
from google.appengine.ext import webapp
from google.appengine.api import memcache
from PycryptoWrap import Tiger


scriptpath = os.path.abspath(os.path.dirname(sys.argv[0]))
peerconf = os.path.join(scriptpath, 'peers.conf')


class StoreKey(db.Model):
    """the database for storing session_id and its correspond session_keys"""
    s_id = db.ByteStringProperty()
    s_key_hmackey = db.BlobProperty()
    date = db.DateTimeProperty(auto_now_add=True)


def dprint(msg, prefix='Debug: '):
    """print debug info on SDK console"""
    logging.info(prefix + msg)


def get_session_key(sess_id):
    """Get the session_key from memcache, if not found, retrive it from GAE
    datastore.
    Args:
        sess_id: the client's session id to look up
    Return:
        {'session_key': sess_key, 'hmac_key': hmac_key}
        """
    s_key_hmackey = memcache.get(sess_id)
    if s_key_hmackey:
        dprint('found key in memcache')

    if not s_key_hmackey:
        stored_keys = db.GqlQuery('SELECT * FROM StoreKey WHERE s_id = :1',
                                  base64.b64encode(sess_id)).get()

        s_key_hmackey = stored_keys.s_key_hmackey
        dprint('found key in datastore')
        if not memcache.set(key=sess_id, value=s_key_hmackey):
            logging.error('session keys Memcache set failed.')

    dprint('hash of hmac & sess key is %s' %
           hashlib.md5(s_key_hmackey).hexdigest())
    sess_key = s_key_hmackey[:Tiger.SKEY_SIZE]
    hmac_key = s_key_hmackey[Tiger.SKEY_SIZE:Tiger.SKEY_SIZE +
                                                    Tiger.HMACKEY_SIZE]
    for x in (sess_key, hmac_key):
        dprint('hash of hmac/sess key is %s' % hashlib.md5(x).hexdigest())
        dprint('length of hmac/sess key is %d' % len(x))

    return {'session_key': sess_key, 'hmac_key': hmac_key}


def get_config():
    '''parse the configure file, return a dictionary of preconfigured
    shapes and locations'''
    import ConfigParser
    config = ConfigParser.ConfigParser()
    config.readfp(open(peerconf))

    res = {'self': {'priv': ''},
           'vessels': {}, 'vips': {}}

    for sec in config.sections():
        if 'self' in sec:
            res['self']['priv'] = config.get(sec, 'priv')

        elif 'vessel' in sec:
            vname = config.get(sec, 'name')
            res['vessels'][vname] = config.get(sec, 'pub')

        elif 'vip' in sec:
            vname = config.get(sec, 'name')
            res['vips'][vname] = config.get(sec, 'pub')

    return res


class ProtocolAbort(Exception):
    pass


class ServerHello(Tiger):
    """server reply to client request"""
#     def __init__(self):
        # runtime_config = get_config()
        # self.rsa_priv = self.import_key(runtime_config['self']['priv'])
        # self.rsa_pubs = {}
        # for vessel, pub in runtime_config['vessels'].iteritems():
            # self.rsa_pubs[vessel] = self.import_key(pub)

    def onestep(self, msg):
        """Received a onestep client hello message, which formatted as:
        session_id + RSA(aes keys) + AES(vessel name)

        the sever will find the stored client public key, use it to encrypt a
        newly generated aes key set, then encapsule it by encrypt it using the
        first aes key generated by the client

        if above fail, the server will remain silent

        """
        runtime_config = get_config()
        self.runtime_config = runtime_config
        self.rsa_priv = self.import_key(open(runtime_config['self']['priv']))
        self.rsa_pubs = {}
        for vessel, pub in runtime_config['vessels'].iteritems():
            self.rsa_pubs[vessel] = self.import_key(open(pub))

        for vip, pub in runtime_config['vips'].iteritems():
            self.rsa_pubs[vip] = self.import_key(open(pub))

        res = None

        #sess_id = msg[:Tiger.SID_SIZE]
        e_aeskeys = msg[:Tiger.RSAOBJ_SIZE]
        aeskeys = self.rsa_priv.decrypt(e_aeskeys)
        session_key = aeskeys[:Tiger.SKEY_SIZE]
        session_hmac_key = aeskeys[Tiger.SKEY_SIZE:Tiger.SKEY_SIZE +
                                                        Tiger.HMACKEY_SIZE]

        d_msg = self.decrypt_aes(msg[Tiger.RSAOBJ_SIZE:],
                                 aeskey=session_key,
                                 hmackey=session_hmac_key)
        vessel_name = d_msg[:20].strip()

        client_pre_master_secret = d_msg[20:]

        # generate new aes key, store it in memcache, then encrypt by
        # client's RSA pub key, and send
        # By default, values stored in memcache are retained as long as
        # possible
        newsession_key_soup = os.urandom(Tiger.RSAOBJ_SIZE - 1)
        newsession_id = newsession_key_soup[:Tiger.SID_SIZE]
        newsession_key_hmackey = newsession_key_soup[
                                     Tiger.SID_SIZE:Tiger.SID_SIZE +
                                                    Tiger.SKEY_SIZE +
                                                    Tiger.HMACKEY_SIZE]
        storekey = StoreKey(s_id=base64.b64encode(newsession_id),
                           s_key_hmackey=newsession_key_hmackey)
        storekey.put()
        memcache.set(key=newsession_id,
                    value=newsession_key_hmackey,
                    time=86400)  # default key expire in 24h
        client_pub = self.rsa_pubs[vessel_name]

        e_newaeskeys = client_pub.encrypt(newsession_key_soup, '')[0]
        server_finish = self.encrypt_aes(client_pre_master_secret,
                         aeskey=newsession_key_hmackey[:Tiger.SKEY_SIZE],
                         hmackey=newsession_key_hmackey[Tiger.SKEY_SIZE:])
        res = e_newaeskeys + server_finish
        return res


class AESHandshake(webapp.RequestHandler, ServerHello):
    #def __init__(self):
    #    self.rsa_pub = self.load_rsa_key(open('pub.asc'))
    #    self.rsa_priv = self.load_rsa_key(open('priv.asc'))

    # when AESHandshake inherit new webapp2.RequestHandler, the __init__
    # will report error:
    # "in __call__
    #        handler = self.handler(request, response)
    #        TypeError: __init__() takes exactly 1 argument (3 given) "
    # disable __init__ solved this problem

    TEST_PAGE = '''<HTML><HEAD><TITLE>Test Page</TITLE></HEAD>
    <BODY> <H1>It Worked!</H1>
    If you can see this, then your installation was successful.
    <P></BODY></HTML>'''

    def get(self):
        self.response.headerlist = [('Content-type', 'text/html')]
        self.response.out.write(self.TEST_PAGE)
        return

    def post(self):
        self.response.headers["Content-Type"] = "application/octet-stream"

        msg = self.request.body
        srv_resp = self.onestep(msg)

        if srv_resp:
            self.response.out.write(srv_resp)
        else:
            self.response.status = 404
            self.response.headerlist = [('Content-type', 'text/html')]
            self.response.out.write('Oops')


def main():
    application = webapp.WSGIApplication([('/login.html', AESHandshake), ])
    wsgiref.handlers.CGIHandler().run(application)


if __name__ == "__main__":
    main()
